# Builder建造模式

## 使用示例

通过Lombok的@Builder注解使用

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ApiModel(description = "员工登录返回的数据格式")
public class EmployeeLoginVO implements Serializable {
    @ApiModelProperty("主键值")
    private Long id;

    @ApiModelProperty("用户名")
    private String userName;

    @ApiModelProperty("姓名")
    private String name;

    @ApiModelProperty("jwt令牌")
    private String token;
}
```



```java
    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping("/login")
    public BaseResponse<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
        log.info("员工登录: {}", employeeLoginDTO);
        Employee employee = employeeService.login(employeeLoginDTO);

        // 登录成果生成Jwt令牌
        Map<String, Object> claims = new HashMap<>();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(jwtProperties.getAdminSecretKey(), jwtProperties.getAdminTtl(), claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return BaseResponse.success(employeeLoginVO);
    }
```



## 相比用BeanUtils的copyProperties

```java
EmployeeLoginVO vo = new EmployeeLoginVO();
// 1. 先拷贝能拷贝的 (id, name, username)
BeanUtils.copyProperties(employee, vo); 
// 2. 再手动补上不能拷贝的
vo.setToken(token); 
// 3. 注意：如果 username 在实体里叫 username，在VO里叫 userName，BeanUtils 也拷不过去
```



| **特性**     | **Builder 模式**                                         | **BeanUtils.copyProperties (反射复制)**                     |
| ------------ | -------------------------------------------------------- | ----------------------------------------------------------- |
| **适用场景** | 字段较少、字段名不完全一致、需要额外计算字段（如 Token） | 字段非常多（如20个以上）、且字段名完全一致                  |
| **性能**     | **极快** (普通的方法调用)                                | **较慢** (使用反射机制，有开销)                             |
| **安全性**   | **编译期检查** (写错字段名直接报红)                      | **运行时检查** (写错名字不报错，只是跑起来没数据，难以排查) |
| **灵活性**   | 高 (可以随意映射不同名字的字段)                          | 低 (必须属性名完全一样)                                     |

> `BeanUtils` 的开销确实比直接写 `get/set` 要大，因为它底层使用了**反射（Reflection）**。但是，**在大多数非高并发、非循环处理的业务场景下（比如你的登录接口），这个性能损耗是可以忽略不计的。**



## 属性拷贝的性能梯队

| **排名** | **方式**                                        | **原理**           | **评价**                                                     |
| -------- | ----------------------------------------------- | ------------------ | ------------------------------------------------------------ |
| **NO.1** | **直接 Get/Set** (或 Builder)                   | 硬编码             | **最快**（基准），JVM 会深度优化。                           |
| **NO.2** | **MapStruct** (强烈推荐)                        | **编译期生成代码** | **几乎等于 Get/Set**。它在编译时自动生成了 Get/Set 代码，**运行时没有反射**。 |
| **NO.3** | Cglib BeanCopier                                | 字节码生成         | 很快，接近原生，但API稍微麻烦点。                            |
| **NO.4** | **Spring BeanUtils** (`org.springframework...`) | 优化的反射         | **中规中矩**。Spring 内部做了缓存优化，日常业务逻辑完全够用。 |
| **NO.5** | **Apache BeanUtils** (`org.apache.commons...`)  | 笨重的反射         | **极慢，严禁使用！** 它由于包含大量的类型转换和校验，性能非常差（比 Spring 慢 10 倍以上）。 |



# Mybatis-Plus的分页配置

## 配置拦截器

```java
package com.hongs.skyserver.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("com.hongs.skyserver.mapper")
public class MybatisPlusConfig {

    /**
     * 添加分页插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
```



在使用Springboot3的 `mybatis-plus-spring-boot3-starter` 需要引入 `mybatis-plus-jsqlparser`

```
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-spring-boot3-starter</artifactId>
    <version>3.5.1</version>
</dependency>

<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-jsqlparser</artifactId>
    <version>3.5.1</version>
</dependency>
```

否则 `PaginationInnerInterceptor` 查找不到



## Service 层实现逻辑

```java
    /**
     * 员工分页查询
     * @param pageQueryDTO
     * @return
     */
    @Override
    public PageResult<EmployeePageQueryVO> page(EmployeePageQueryDTO pageQueryDTO) {
        IPage<Employee> iPage = new Page(pageQueryDTO.getPage(), pageQueryDTO.getPageSize());
        LambdaQueryWrapper<Employee> wrapper = new LambdaQueryWrapper<>();
        wrapper.orderByDesc(Employee::getUpdateTime)
                .orderByDesc(Employee::getCreateTime);
        wrapper.like(StringUtils.hasText(pageQueryDTO.getName()), Employee::getName, pageQueryDTO.getName());
        this.page(iPage, wrapper);

        List<EmployeePageQueryVO> voList = iPage.getRecords().stream().map(employee -> {
            EmployeePageQueryVO vo = new EmployeePageQueryVO();
            BeanUtils.copyProperties(employee, vo);
            return vo;
        }).toList();

        return new PageResult<EmployeePageQueryVO>(iPage.getTotal(), voList);
    }
```



# 常用判空方法

分为 **字符串**、**集合/数组**、**通用对象** 三大类来列举



## 一、 字符串判空

字符串的“空”有三种情况：

1. `null` (真空)
2. `""` (空字符串，长度为0)
3. `"   "` (只有空格，长度大于0，但在业务上通常视为无意义)



**字符串判空图解：**

| **输入值**   | **str.isEmpty() (原生)** | **StringUtils.isEmpty (Spring)** | **StringUtils.hasText (Spring) ✅** |
| ------------ | ------------------------ | -------------------------------- | ---------------------------------- |
| `null`       | ❌ 报空指针               | `true`                           | `false`                            |
| `""`         | `true`                   | `true`                           | `false`                            |
| `" "` (空格) | `false`                  | `false` (坑!)                    | **`false`** (智能)                 |
| `"abc"`      | `false`                  | `false`                          | `true`                             |


1. `StringUtils.hasText(str)`

- **来源**：`org.springframework.util.StringUtils`
- **作用**：**最严格**。必须有实际字符才算 true。
- **判断逻辑**：`!= null` **且** `length > 0` **且** `包含非空格字符`。
- **适用场景**：用户名、搜索关键词等不允许只填空格的场景。

2. `StringUtils.isEmpty(str)` / `hasLength(str)`

- **来源**：`org.springframework.util.StringUtils`
- **作用**：只判断有没有长度。
- **坑点**：`"   "` (三个空格) 会被认为是 **有值** (true)。
- **适用场景**：你认为“空格”也是一种有效数据的场景（极少见）。

3. `str.isBlank()`

- **来源**：JDK 11 String 类自带方法

- **作用**：等同于 Spring 的 `!hasText()`。

- **写法**：
	```Java
	if (str != null && !str.isBlank()) { ... }
	```

- **缺点**：因为是实例方法，如果 `str` 本身是 `null`，直接调用 `str.isBlank()` 会报 **空指针异常 (NPE)**。所以必须先判断 `!= null`。



## 二、 集合与 Map 判空 (List, Set, Map)

判断集合是否为 null 或者 size 为 0。

1. `CollectionUtils.isEmpty(list)` 【Spring 推荐】

- **来源**：`org.springframework.util.CollectionUtils`

- **代码**：

	```Java
	List<Employee> list = null;
	if (CollectionUtils.isEmpty(list)) {
	    // list 是 null 或者 size=0 都会进这里
	    return; 
	}
	```

- **优点**：**空指针安全**。如果用原生写法 `list.size() == 0`，当 list 为 null 时会报错。

2. `MapUtils.isEmpty(map)`

- **来源**：`org.apache.commons.collections` (或者 Spring 的 `CollectionUtils` 也可以判断 Map)
- **代码**：`CollectionUtils.isEmpty(map)` (Spring 通吃)



## 三、 对象判空 (Object)

1. `obj == null` (原生，最常用)

- 简单粗暴，如果是普通对象，直接用 `!= null` 即可。

2. `Objects.isNull(obj)` / `Objects.nonNull(obj)` 【Java 7+ 原生】

- **来源**：`java.util.Objects`

- **代码**：

	```Java
	if (Objects.nonNull(employee)) {
	    // ...
	}
	```

- **优点**：适合配合 Java 8 的 `Stream` 流使用，例如 `.filter(Objects::nonNull)`，写在普通 `if` 里只是为了读起来像英语，功能和 `!= null` 一模一样。

3. `ObjectUtils.isEmpty(obj)` 【Spring 全能王】

- **来源**：`org.springframework.util.ObjectUtils`

- **特点**：**万能**。它可以判断 String、List、Map、数组、Optional 甚至是普通对象。

- **代码**：

	```java
	ObjectUtils.isEmpty(new int[]{}); // true
	ObjectUtils.isEmpty("  "); // false (注意！它不检查空格，只检查长度)
	ObjectUtils.isEmpty(null); // true
	```



## 四、 数组判空 (Array)

1. `arr != null && arr.length > 0` (原生)

最基础的写法。

2. `ObjectUtils.isEmpty(arr)` (Spring)

Spring 的 `ObjectUtils` 底层会自动识别这是一个数组，并判断长度。


## 总结：Spring Boot 项目最佳实践

| **数据类型**   | **推荐方法**                    | **理由**                             |
| -------------- | ------------------------------- | ------------------------------------ |
| **String**     | `StringUtils.hasText(str)`      | 唯一能过滤掉“纯空格”的方法，最安全。 |
| **List/Set**   | `CollectionUtils.isEmpty(list)` | 防止 List 为 null 时报空指针。       |
| **Map**        | `CollectionUtils.isEmpty(map)`  | 同上。                               |
| **普通对象**   | `obj != null`                   | 简单直接。                           |
| **Stream流中** | `Objects::nonNull`              | 代码优雅，可读性高。                 |
